# Week 1 (2023-02-01 ~ 2023-02-12)

## GoF 디자인 패턴

### 브릿지 (Bridge) 패턴
- 추상적인 부분과 구체적인 부분을 분리하여 연결하는 패턴
- 장점
    - 추상적인 코드와 구체적인 코드를 분리 가능
    - 추상적인 코드를 구체적인 코드 변경 없이도 독립적으로 확장 가능
- 단점
    - 계층 구조가 늘어나서 복잡해짐

### 컴포짓 (Composit) 패턴
- JAVA는 컴파일 시점에 `@Override` 애노테이션이 붙은 구현체의 메서드가 실제로 상속 스펙에 잘 맞는지 확인하므로 중요한 애노테이션이다.
- 가장 추상적인 타입을 사용해야 한다.
- 공통된 인터페이스를 정의해야 하기 때문에 지나친 일반화 해야 하는 경우가 생길 수 있다.

### 데코레이터 (Decorator) 패턴
- 예제 : 덧글을 출력해주는 코멘트 서비스
    - 확장 1 : Trim 확장
    - 확장 2 : http 필터 확장
    - 확장으로 처리하기는 한계가 있음 (너무 많아짐)

- 상속이 아닌 위임을 통해 기능을 확장하는 패턴

### 퍼사드 (Facade) 패턴
- 복잡한 서브시스템 의존성을 최소화 하는 패턴
- 퍼사드는 건물의 정면(겉으로 보이는 부분)을 의미하는 불어
- 표면에 최대한 로직이 드러나지 않도록 (약한 결합이 되도록) 설계하는 방법
- 1차적인 추상화가 이루어지기 때문에 코드가 한층 이해하기 쉬워진다.
- 서브 시스템에 대한 의존성을 한 곳으로 모을 수 있다.
    - 퍼사드 클래스가 서브 시스템에 대한 모든 의존성을 갖게 된다.
- 퍼사드 패턴 상상이미지
    - 전화로 주문(Client) - 접수 콜센터 (facade class) - 생성/포장/유통 등 복잡한 로직(sub systems)

### 플라이웨이트 (Flyweight) 패턴
- 자주 사용하는 부분을 캐시하여 모델의 용량을 줄이는 패턴
- 코드가 복잡해지기 때문에 주석등을 통하여 패턴을 구축하는 이유를 꼭 설명한다.
- Integer 등의 정수형 객체에도 플라이웨이트 패턴이 적용되어 있음
```java
    Integer i1 = 10;
    Integer i2 = 10;

    System.out.println(i1 == i2); // true

    Integer i3 = 10000000;
    Integer i4 = 10000000;

    System.out.println(i3 == i4) //false

    //정수형 Box 객체 값 비교시에는 꼭 equals를 사용해야 한다.
```

### 프록시 (Proxy) 패턴
- 굉장히 자주 사용되는 디자인 패턴이다.
- 기존 객체를 건드리지 않고 동작 추가, 지연 로딩 등 다양하게 활용 가능하다.
- 인터페이스를 통한 구현으로 활용하는 것이 좋다.

### 책임 연쇄 (Chain of Responsibilities) 패턴
- 요청을 보내는 쪽과 처리하는 쪽을 분리하는 패턴
- 체인을 구성하는 방법에 따라 다양한 순서나 조건을 적용할 수 있다.
- 디버깅하기가 까다로워질 수 있다.
- 스프링 시큐리티
    - 거대한 서블릿 필터 체인이다.

### 커맨드 (Command) 패턴
- 요청을 캡슐화 하여 호출자와 수신자를 분리하는 패턴

### 인터프리터 (Interpreter) 패턴
- 자주 등장하는 문제를 간단한 언어로 정의하고 재사용하는 패턴
- Expression 과 Parser 를 구현하여 표현식을 정의한다.

### 이터레이터 (Iterator) 패턴
- 집합 객체 내부 구조를 노출시키지 않고 순회하는 방법을 제공하는 패턴
- 내부 집합객체가 어떤 타입인지 노출되지 않는다.
- 이터레이터 사용 방식 변화
```Java
        //Java 8 이전
        Iterator<Post> iterator1 = board.getPosts().iterator();
        while (iterator1.hasNext()) {
            Post next = iterator1.next();
            System.out.println(next.getTitle());
        }

        //Java 8 이후
        board.getPosts().iterator()
            .forEachRemaining(post -> System.out.println(post.getTitle()));
```