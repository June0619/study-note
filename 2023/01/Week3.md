# Week 3 (2023-01-23 ~ 2023-01-31)

## Spring 개념원리 기본
### 빈 스코프와 빈 생명주기
- 
<br>

---

<br>

## GoF 디자인 패턴
### 팩토리 메소드 (Factory Method)
- 구체적으로 어떤 것(Product) 를 생산할 지 서브 클래스 (Factory) 가 결정한다.
- OCP 원칙을 따르며 구현체 클래스를 통해 생산자를 확장해나간다.
- 생산자조차 인터페이스 기반으로 변경에 닫혀있도록 설계한다 (이 과정에서 일종의 DI 가 성립된다)
- 팩토리 메소드 패턴 Example
    - `java.lang.Calendar` 혹은 `java.lang.NumberFormat`
    - `BeanFactory` - Factory / Xml or Bean - Product

### 추상 팩토리 (Abstract factory) 패턴
- 서로 관련있는 여러 객체를 만들어주는 인터페이스
- 팩토리 메소드 패턴과 비슷하지만 주체가 클라이언트에 있다.

### 팩토리 메소드와 추상 팩토리 패턴의 차이
- 사실 둘이 내용은 비슷하지만 디자인 패턴을 바라보는 관점에 차이가 있다.
- 팩토리 메소드 패턴은 팩토리를 구현하는 방법 (객체 생산)에 초점을 맞춘다.
- 추상 팩토리 패턴은 팩토리를 사용하는 방법에 초점을 맞춘다.

### 추상 팩토리 패턴의 사용 예제
- Spring 에서 쉽게 객체를 추상 팩토리 패턴으로 제공하도록 `FactoryBean` 이라는 인터페이스를 제공한다.
- 해당 인터페이스를 상속받아 스프링 컨텍스트에서 관리하는 Factory 를 등록할 수 있다.

### 빌더 (Builder) 패턴
- 객체의 필드가 여러개인 경우 객체에 값을 세팅하는 과정이 너무 번거롭다.
    - 필수값을 강제하거나 생성자를 만드는 과정이 어렵다.
- 예제
    - Lombok 의 Builder
    - Spring UriComponent


### 프로토타입 (Prototype) 패턴
- 특정 객체와 내용이 거의 비슷한 인스턴스를 생성해야 할 경우 사용한다.
- 기존 객체의 내용을 복사하는 패턴이다.
- 장점
    - 객체를 만드는 과정을 숨길 수 있다.
    - 새 인스턴스를 만드는 것 보다 비용이 적을 수 있다.
    - 추상적 타입을 리턴할 수 있다.
- 단점
    - 순환 참조가 있는 경우 비용이 커질 수 있다.


### 어댑터 패턴
- 기존 코드를 클라이언트가 사용하는 인터페이스의 구현체로 바꿔주는 패턴
- OCP / SRP 원칙을 준수할 수 있다.
- 어댑터 패턴을 사용하지 않으려면 클라이언트의 인터페이스를 <b>직접 상속</b> 받으면 된다.
- 복잡도가 올라갈 수 있다.
- 사용 예제
    - Collections, IO, HandlerAdapter

<br>

---

<br>

## JAVA

### 타입 추론
- 제네릭에서 타입이 생략된 경우는 일반적으로 Object 타입으로 간주한다. 하지만 다음과 같은 경우 타입 추론이 가능하다.
    ```java
    List<String> stringArr = new ArrayList<>();
    ```
    
    하지만 다음과 같이 타입 추론이 이루어지기 전 특정 타입을 강제로 사용하게 되면 에러가 발생한다.

    ```java
    //Stram.builder() 메소드가 Object 타입을 가진 제네릭 메소드로 간주 됨
    Stream<String> strings = Stream.builder().add("string1").add("string2").build();
    ```