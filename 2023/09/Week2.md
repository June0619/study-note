# Week 2 (2023-09-11 ~ 2023-09-17)

## Spring DB 1편 - 스프링 트랜잭션

### 기존 트랜잭션 적용 방식의 문제점
- 순수해야 하는 서비스 계층에 JDBC 관련 기술이 누수되었다.
- 트랜잭션을 유지하기 위해 `Connection` 객체를 계속 다른 DB 메소드에 전파해야 한다.
- 반복적인 코드가 많이 발생한다. (try, catch finally...)
- 데이터 접근 계층의 예외가 서비스 레이어로 전파된다.
    - 심지어 `SQLException` 은 JDBC 전용 예외이며, JPA 나 별도의 기술이므로 데이터 접근 기술이 변경되면 다른 예외를 다루어 주어야 한다.

### 트랜잭션 추상화
- 앞서 나온 문제들을 해결하기 위해서는 트랜잭션 기능들을 추상화 할 필요가 있다.

- 단순하게 다음과 같은 트랜잭션 인터페이스를 만든다고 가정하자.

```java
public interface TxManager {
    begin();
    commit();
    rollback();
}
```

- 실제로 트랜잭션은 크게만 보면 작업 시작 - 커밋 / 롤백 이외에는 수행 할 임무가 없다.

- 그리고 각 기술별로 JDBC/JPA 등 같이 각자의 기술에 맞는 구현체를 만들어 사용하면 된다.

- 사실 스프링에서는 이미 이렇게 트랜잭션을 관리하는 주체가 추상화 되어있는데 이것이 바로 `PlatformTransactionManager` 이다.
    - 기술별로 `DataSourceTransactionManager` , `JpaTransactionManager` 등이 있다.

### 트랜잭션 동기화

- 스프링이 제공하는 트랜잭션 메니저는 추상화 뿐만 아니라 트랜잭션 동기화도 지원해야 하는데, 이는 트랜잭션 범위 내의 작업들이 같은 `Connection` 객체를 사용하도록 돕는것을 의미한다.

- 위 작업은 **트랜잭션 동기화 매니저** 를 통해 이루어지는데 쓰레드 로컬을 이용한다. 따라서 멀티쓰레드 상황에서 Thread Safe 하게 동기화를 할 수 있다.

### 트랜잭션 매니저의 문제 해결 흐름

1. 서비스 계층에서 `transactionManager.getTransaction()` 을 통해 트랜잭션을 시작한다.
    - 이 때 `TransactionManager` 에는 `PlatformTransactionManager` 를 DI 받는다. 그러면 DB 접근 기술에 따라 의존성이 주입된다.
2. 트랜잭션을 시작하기 위해서는 DB 커넥션이 필요한데, 트랜잭션 매니저는 데이터 소스를 이용해 커넥션을 CP 에서 가져오거나 없다면 생성한다.
3. 커넥션을 Auto Commit 으로 변경 후 트랜잭션을 시작한다.
4. 커넥션을 로직 중 트랜잭션 매니저에 보관한다.
5. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다.
6. 서비스에서 비지니스 로직들을 실행하는데 커넥션이 파라미터로 돌아다니지 않는다.
7. 레포지토리에서는 `TrnasactionManager` 객체가 동기화 매니저에 보관된 커넥션을 전다해준다.
8. 획득한 커넥션을 통해 SQL 등을 전달한다.
9. 트랜잭션을 커밋하거나 롤백하므로써 종료한다. 이 때, 트랜잭션 동기화 매니저에 보관된 커넥션 객체를 통해 명령을 수행한다.
10. 쓰레드 로컬, 트랜잭션 동기화 매니저, 커넥션(auto commit 설정 포함) 등을 정리한다.

### 트랜잭션 템플릿
- 핵심 비즈니스 로직을 제외한 트랜잭션 관련 코드들은 너무 반복된다.
- 템플릿 콜백 패턴이 적용된 트랜잭션 템플릿을 사용하여 이런 문제들을 해결한다.
- 하지만 아무리 트랜잭션 템플릿을 이용하여 반복적인 코드를 줄인다고 해도 서비스 레이어에 트랜잭션 관련 코드는 남기 마련이다.
    - 어떻게 이러한 문제를 해결할 수 있을까?